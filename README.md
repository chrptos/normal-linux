# normal-linux
ふつうのLinux入門学習用

# 3章
- ファイルシステム(p43)
    - regular file, directory, symbolic link, device file, named pipe, UNIX domain socket
    - device file: character device file, block device file
- ストリーム(p48)
    - システムコールでカーネルによってストリームが作られて、また、システムコールを利用してストリームを操作することで入出力を制御します。
    - ストリームには様々な種類があり、ファイルに繋がったものもあれば、デバイスに繋がったものもあります。プロセスはストリーム経由でファイルやデバイスにアクセスします。
    - また、パイプもストリームの一種です。パイプはファイルやデバイスではなく、プロセス通しをつなげます。
    - 他にも、ネットワークに対応しています。例）端末A-プロセスA-カーネルA-ストリーム（ネットワーク）-カーネルB-プロセスB-端末B

# 4章
- ユーザーベース、シェル
- クレデンシャル(p60)

# 5章
- read: ストリームからバイト列を読み込む
- write: ストリームにバイト列を書き込む
- open: ストリームを作る
- close: ストリームを削除する

- 様々な理由からプロセスからストリームを見せるわけには行かないので、ファイルディスクリプタを通してアクセスします。(p76)
    - カーネル（ストリームa=0） --- (ファイルディスクリプタ0)プロセスのように対応付けします。
    - どのプロセスにも3つのストリームが用意されている
        - 標準入力: 0番
        - 標準出力: 1番
        - 標準エラー: 2番

- コラム：本書におけるストリームとは
    - 本書のストリームとは、ファイルディスクリプタで表現され、read()またはwrite()で操作できるもののことです。例えば、ファイルをopen()するとread()またはwrite()を実行できるものが作られますから、そこにはストリームがあります。

# 6章
- バッファリング： システムコールで1バイトずつ読み込むのは低速なので、バッファリングしてそこから読み込む（p１０２）
    - FILE: 型、ファイルディスクリプタとstdioバッファの内容
    - fgetcやfputcのバイト単位の入出力は何に使用するのですか？
        - 文字単位での処理やバイナリ単位での操作（画像とか）
        - バイナリやテキストを判別する必要がなくファイルの内容をそのままコピーする場合など
        - シリアル通信
        - fgetcとgetcharの違い
            - 汎用性の違いがあります。fgetcはファイルストリームを利用して汎用的な読み込みを可能にします。getcharは標準入力(キーボード)のみに限定されています。
        - ungetc: 読み込みを再開できる
- 入力
    - fgets(): 行単位での読み込みを行います。size-1バイトまでしか読み込みません。
        - size-1バイトまでしか読み込まないのは、読み込んだ文字を完全な文字列として読み込むためです。終端文字(`\0`)を追加します。
        - ただ、ちゃんと1行丸ごと読み込んだのか？バッファがいっぱいで読み込めないのか判別できない問題点があります。
    - gets(): 使わないこと。バッファ指定ができないのでバッファオーバーフローを起こす。
    - scanf: gets()と同様にバッファを指定できないので、オーバーフローを起こす危険性があるので使わないでください。
    - puts()とfputs()の違い？
        - puts()は標準出力に固定されており、末尾に'\n'を追加します。
    - getc(): ストリームから1文字読み込む
- 出力
    - printf(): 標準出力に出したい時に利用されますが、フォーマットが必要ない時にprintf()を使う必然性はないはずです。
    - fputs(): 指定したファイルストリームに文字列を書き込みます。標準出力を明示的に指定しなければいけません。
    - puts(): 文字列を標準出力します。末尾に`\n`が追加されてしまいます。
    - putchar(): 単一文字を標準出力します。
    - 注意点: printf()を利用してもいいが、入力に`%`が含まれる場合は致命的なエラーにつながります。`printf(%s, s)`のように`%s`を利用して出力してください。
- 固定長の入出力
    - read()とfread()の違いは、システムコールであるかどうか？バッファを利用するかという点です。
    - FILE型とファイルディスクリプタとfreadの関係性
        - 関係性
            - FILE 型とファイルディスクリプタの橋渡し：
                - FILE 型のストリームは内部的にはファイルディスクリプタを使用してファイルシステムとのやり取りを行います。FILE 型はファイルディスクリプタをより使いやすく抽象化したものです。
                - fdopen 関数は、既存のファイルディスクリプタを FILE 型のストリームに変換します。これにより、低レベルのファイルディスクリプタインターフェースと高レベルの FILE ストリーム間のギャップを埋めます。
            - fread と FILE 型：
                - fread は FILE 型のストリームを介してデータを読み込みます。このプロセスは自動的にバッファリングが行われ、複数の小さなデータ読み込みが最適化されます。
- open(), fdopen(), fopen()の関係性
    - open()はシステムコールでユーザーグループなどのレベルでパーミッションを設定して、fdを作成できる。fopen()は書き込み、読み取りなどのプログラムレベルでのパーミッションを制御できます。
    - open()だけだとfdは作成できてもストリームが作成されないので、フォーマットやバッファなどがないので扱いにくい。なのでfdopen()でfdからストリームを作成するのが一般的です。
    - fopen()はパーミッション指定はできないが、新規fdを作成しつつ、ストリームも作成してくれるので簡単で扱いやすいです。
- なぜストリームが必要なのか？
    - ストリームは、データの連続的な処理に関して多くの利点を提供します。プログラミングにおいて、ストリームはデータの読み込みや書き込みを抽象化し、一連のデータとして扱うことを可能にします。以下では、ストリームの主な利点を詳しく説明します。
        1. 抽象化と単純化
        ストリームはファイル、ネットワーク接続、メモリ内のデータなど、さまざまなデータソースに対して統一されたインターフェースを提供します。この抽象化により、データの具体的な格納方法や転送方法について詳しく知る必要がなく、データの読み書きに集中できます。
        2. 効率性とバッファリング
        多くのストリーム実装では、内部バッファリングが行われます。このバッファリングは、データの小さな塊が頻繁に読み書きされることを避け、大きなブロックでのデータ操作を可能にします。これにより、システムコールの数が減少し、全体的なパフォーマンスが向上します。
        3. 非同期処理のサポート
        ストリームは非同期操作に対応していることが多く、データの読み込みや書き込みをバックグラウンドで行うことができます。これにより、プログラムがデータを待つことなく他のタスクを進められるため、アプリケーションの応答性が向上します。
        4. エラー処理
        ストリームはエラーを検出して処理するメカニズムを備えていることが多いです。たとえば、読み書き操作中にエラーが発生した場合、ストリームは適切なエラー状態を保持し、プログラムがこれを検出して対応できるようにします。
        5. リソースの管理
        ファイルストリームを利用する場合、オープンしたファイルのリソースはストリームオブジェクトに結びつけられ、ストリームがクローズされると同時にリソースも適切に解放されます。これにより、リソースリークのリスクが減少します。
        6. データ変換と処理の柔軟性
        ストリームは、データをそのまま扱うだけでなく、読み込み時や書き込み時にフィルタリングや変換を行うことができます。例えば、暗号化、圧縮、文字コード変換などの処理をストリームを通じて透過的に行うことができます。
        7. 大規模データの取り扱い
        ストリームは大規模なデータや無限に近いデータストリームを扱う際にも有効です。データを小分けにして処理するため、全てのデータを一度にメモリに格納する必要がありません。
    - ストリームはこれらの利点により、様々なアプリケーションでデータを効率的かつ効果的に扱うための重要なツールとなっています。ファイル入出力、ネットワーク通信、データ処理タスクなど、多岐にわたる分野でその利点が生かされています。

# 7章
- linuxにおける行とは？
    - `\n`で終わる文字列のことを指します。
- fgets()を使用していないのは何故？
    1. getc()ならバッファが必要ないので扱いが楽
    2. fgets()を使うと、相当工夫しない限り行の長さが制限される
    3. getc()でも困らない
- getopt()
    - パラメータをとるオプションに関しては、`:`をパラメータの後ろに記述する

# 8章
- 正規表現
- 文字コード

# 9章
- ファイルシステム
    - /bin: ブートするときの基本コマンド、/usr/binや/binはディストリビューションが管理するので、自分でインストールするコマンドは/usr/local/binに配置するべきです。
    - /sbin: 管理者用のコマンド置き場です。/usr/sbinには平常時用のシステム管理コマンドやサーバープログラムを置きます。
    - /lib: ライブラリを配置します。C言語のライブラリの他、PerlやRuby、Pythonなどの言語のライブラリを置くこともあります。
    - /etc: 各マシンの設定ファイルを置きます。
    - /dev: デバイスファイルを置きます。
    - /proc: プロセスファイルシステムがマウントされます。プロセスファイルシステムはプロセスをファイルシステムで表現します。プロセスIDが1のプロセス情報を見たければ、/proc/1の中を見れば良いです。
    - /usr: 複数のマシンで共有可能なファイルを置きます。ネットワークファイルシステム（NFSやSAMBA）などを用いて別のマシンのファイルシステムをネットワーク越しにマウントします。
        - /usr/local: 各システムの管理者用のディレクトリ
    - /var: 頻繁に書き換えられるファイルを置きます。共有ファイルはここに置くべきではありません。ログやメールボックスが置かれます。
        - /var/log: ログファイル
        - /var/run: 起動中のプロセスIDが保存されます。
    - /sys: デバイスやデバイスドライバの情報
    - /boot: linuxのカーネルプログラム
    - /tmp: /var/tmpはリブートしても消されない、/tmpは消されます。
    - ディレクトリを分ける基準について（p193）
# 10章
    - ディレクトリの内容を読む
        - ディレクトリの正体は構造体（ディレクトリエントリ）
        - ディレクトリトラバース：　ディレクトリを再帰的に走査する。DFSやBFSがある。
    - ハードリンク
        - Linuxでは2つ以上の名前をファイルに付けることができる。→link
            - `echo 'this is file.' > a`
            - `ln a b`でaとbから実態ファイルへアクセス可能になる。
    - シンボリックリンク
        - 名前から名前にリンクする
        - 対応する実態が存在しなくても良い、アクセスするときに実態との対応付けを行う。
            - ショートカットもリンク先がありませんとなるので、それと同じこと
        - ファイルシステムを跨いで別名を付けられる
        - ディレクトリにも別名が付けられる
# 11章
    - 原則として、CPUとメモリが1つずつしかなければ、プロセスは1つしか動かないということ。
        - なので仮想CPUとメモリでプロセス専用のCPUとメモリを作り出している
    - CPUを増やすには？
        - 非常に短い単位で実行プロセスを切り替えれば、あたかもプロセス専用のCPUがあるかのように見えます。
    - メモリを増やすには？
        - プロセスから見えるアドレスをカーネルとCPUによって処理して、実際のアドレスに翻訳するような仕組みを作ります。
        - 論理アドレスと呼ばれます。実際のアドレスは物理アドレスと呼ばれます。
        - プロセスごとにアドレスを用意することで、プロセス同士は隔離されます。
    - 仮想CPUの実現
        - タイムスライス、スケジューラ、ディスパッチャによって実現されています。優先度を設定して担当プロセスを切り替えていきます。
    - 仮想メモリの実現
        - プロセスのアドレス空間をページ単位（4KB or 8KB)に分割して論理アドレスと物理アドレスをページ単位で紐付けします。
        - この時、論理アドレスは必ずしも物理アドレスに紐づいている必要はなく、必要になれば紐付けすれば良いです。
    - 64bitアーキテクチャ
        - 理論上使用可能な論理アドレス空間が、2^64=16エクサバイトであるコンピュータアーキテクチャを指します。
    - 仮想メモリ機構の応用
        - ページングはページ単位に、スワッピングはプロセス全体単位で論理アドレスの退避と再開を行う
        - 逆に物理メモリとファイルを対応付けしたものがメモリマップトファイルと呼ばれている
        - 共有メモリは特定範囲の物理メモリを複数プロセスで共有する。GIMPは画像ファイルを共有することで処理を軽量化している。
    - プログラムができるまで
        - プリプロセス: `#include`などを処理して純粋なC言語のソースコードを出力する
        - コンパイル: C言語からアセンブリ言語に変換する
        - アセンブル: アセンブリ言語を機械語を含むオブジェクトファイルに変換する
        - リンク: スタティックリンクはコンパイル時に含まれていて、ダイナミックリンクはプログラム実行時に必要なライブラリを読み出す。

# 12章
- プロセスに関わるAPI
    - fork: 親から子プロセスを生成する
    - exec: 現在のプロセスを別のプログラムで上書きする
    - wait: 子プロセスの終了を待つ
- プログラムの実行
    1. forkする
    2. 子プロセスで新しいプログラムをexecする
    3. 親プロセスは子プロセスをwaitする
    
